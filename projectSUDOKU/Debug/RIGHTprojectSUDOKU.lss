
RIGHTprojectSUDOKU.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000099c  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  00800060  00000a10  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000005e  00800060  00800060  00000a10  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000a10  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000a40  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000060  00000000  00000000  00000a7c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000008b6  00000000  00000000  00000adc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000684  00000000  00000000  00001392  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000080b  00000000  00000000  00001a16  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000114  00000000  00000000  00002224  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000003bb  00000000  00000000  00002338  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000001ea  00000000  00000000  000026f3  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000050  00000000  00000000  000028dd  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
   8:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
   c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  10:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  14:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  18:	0c 94 17 02 	jmp	0x42e	; 0x42e <__vector_6>
  1c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  20:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  24:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  28:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  2c:	0c 94 96 02 	jmp	0x52c	; 0x52c <__vector_11>
  30:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  34:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  38:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  3c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  40:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  44:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  48:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  4c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  50:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d4 e0       	ldi	r29, 0x04	; 4
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_clear_bss>:
  60:	20 e0       	ldi	r18, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	01 c0       	rjmp	.+2      	; 0x6a <.do_clear_bss_start>

00000068 <.do_clear_bss_loop>:
  68:	1d 92       	st	X+, r1

0000006a <.do_clear_bss_start>:
  6a:	ae 3b       	cpi	r26, 0xBE	; 190
  6c:	b2 07       	cpc	r27, r18
  6e:	e1 f7       	brne	.-8      	; 0x68 <.do_clear_bss_loop>
  70:	0e 94 44 04 	call	0x888	; 0x888 <main>
  74:	0c 94 cc 04 	jmp	0x998	; 0x998 <_exit>

00000078 <__bad_interrupt>:
  78:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000007c <FindUnassignedLocation>:
	Then, through while loops where is the next position that is unassigned in the grid. The function
	does that by updating both the pointers of the row and column in the grid so when it returns it 
	passes the values and by that the position in the sudoku.
*/
uint8_t FindUnassignedLocation( uint8_t* row, uint8_t* col)
{
  7c:	cf 93       	push	r28
  7e:	df 93       	push	r29
  80:	00 d0       	rcall	.+0      	; 0x82 <FindUnassignedLocation+0x6>
  82:	00 d0       	rcall	.+0      	; 0x84 <FindUnassignedLocation+0x8>
  84:	cd b7       	in	r28, 0x3d	; 61
  86:	de b7       	in	r29, 0x3e	; 62
  88:	9a 83       	std	Y+2, r25	; 0x02
  8a:	89 83       	std	Y+1, r24	; 0x01
  8c:	7c 83       	std	Y+4, r23	; 0x04
  8e:	6b 83       	std	Y+3, r22	; 0x03
	(*row)=0;
  90:	89 81       	ldd	r24, Y+1	; 0x01
  92:	9a 81       	ldd	r25, Y+2	; 0x02
  94:	fc 01       	movw	r30, r24
  96:	10 82       	st	Z, r1
	(*col)=0;
  98:	8b 81       	ldd	r24, Y+3	; 0x03
  9a:	9c 81       	ldd	r25, Y+4	; 0x04
  9c:	fc 01       	movw	r30, r24
  9e:	10 82       	st	Z, r1
    while((*row)<N) // checks the remaining rows one by one
  a0:	3d c0       	rjmp	.+122    	; 0x11c <FindUnassignedLocation+0xa0>
	{
        while((*col)<N) // check the values of each row 
		{
            if (grid[*row][*col] == UNASSIGNED)
  a2:	89 81       	ldd	r24, Y+1	; 0x01
  a4:	9a 81       	ldd	r25, Y+2	; 0x02
  a6:	fc 01       	movw	r30, r24
  a8:	80 81       	ld	r24, Z
  aa:	28 2f       	mov	r18, r24
  ac:	30 e0       	ldi	r19, 0x00	; 0
  ae:	8b 81       	ldd	r24, Y+3	; 0x03
  b0:	9c 81       	ldd	r25, Y+4	; 0x04
  b2:	fc 01       	movw	r30, r24
  b4:	80 81       	ld	r24, Z
  b6:	48 2f       	mov	r20, r24
  b8:	50 e0       	ldi	r21, 0x00	; 0
  ba:	c9 01       	movw	r24, r18
  bc:	88 0f       	add	r24, r24
  be:	99 1f       	adc	r25, r25
  c0:	88 0f       	add	r24, r24
  c2:	99 1f       	adc	r25, r25
  c4:	88 0f       	add	r24, r24
  c6:	99 1f       	adc	r25, r25
  c8:	82 0f       	add	r24, r18
  ca:	93 1f       	adc	r25, r19
  cc:	84 0f       	add	r24, r20
  ce:	95 1f       	adc	r25, r21
  d0:	80 5a       	subi	r24, 0xA0	; 160
  d2:	9f 4f       	sbci	r25, 0xFF	; 255
  d4:	fc 01       	movw	r30, r24
  d6:	80 81       	ld	r24, Z
  d8:	88 23       	and	r24, r24
  da:	11 f4       	brne	.+4      	; 0xe0 <FindUnassignedLocation+0x64>
			{
                return 1; // the row, col are already updated so there is nothing to be done
  dc:	81 e0       	ldi	r24, 0x01	; 1
  de:	25 c0       	rjmp	.+74     	; 0x12a <FindUnassignedLocation+0xae>
			}
			(*col)++;
  e0:	8b 81       	ldd	r24, Y+3	; 0x03
  e2:	9c 81       	ldd	r25, Y+4	; 0x04
  e4:	fc 01       	movw	r30, r24
  e6:	80 81       	ld	r24, Z
  e8:	21 e0       	ldi	r18, 0x01	; 1
  ea:	28 0f       	add	r18, r24
  ec:	8b 81       	ldd	r24, Y+3	; 0x03
  ee:	9c 81       	ldd	r25, Y+4	; 0x04
  f0:	fc 01       	movw	r30, r24
  f2:	20 83       	st	Z, r18
{
	(*row)=0;
	(*col)=0;
    while((*row)<N) // checks the remaining rows one by one
	{
        while((*col)<N) // check the values of each row 
  f4:	8b 81       	ldd	r24, Y+3	; 0x03
  f6:	9c 81       	ldd	r25, Y+4	; 0x04
  f8:	fc 01       	movw	r30, r24
  fa:	80 81       	ld	r24, Z
  fc:	89 30       	cpi	r24, 0x09	; 9
  fe:	88 f2       	brcs	.-94     	; 0xa2 <FindUnassignedLocation+0x26>
			{
                return 1; // the row, col are already updated so there is nothing to be done
			}
			(*col)++;
		}
		(*col)=0; // end of the row
 100:	8b 81       	ldd	r24, Y+3	; 0x03
 102:	9c 81       	ldd	r25, Y+4	; 0x04
 104:	fc 01       	movw	r30, r24
 106:	10 82       	st	Z, r1
		(*row)++;
 108:	89 81       	ldd	r24, Y+1	; 0x01
 10a:	9a 81       	ldd	r25, Y+2	; 0x02
 10c:	fc 01       	movw	r30, r24
 10e:	80 81       	ld	r24, Z
 110:	21 e0       	ldi	r18, 0x01	; 1
 112:	28 0f       	add	r18, r24
 114:	89 81       	ldd	r24, Y+1	; 0x01
 116:	9a 81       	ldd	r25, Y+2	; 0x02
 118:	fc 01       	movw	r30, r24
 11a:	20 83       	st	Z, r18
*/
uint8_t FindUnassignedLocation( uint8_t* row, uint8_t* col)
{
	(*row)=0;
	(*col)=0;
    while((*row)<N) // checks the remaining rows one by one
 11c:	89 81       	ldd	r24, Y+1	; 0x01
 11e:	9a 81       	ldd	r25, Y+2	; 0x02
 120:	fc 01       	movw	r30, r24
 122:	80 81       	ld	r24, Z
 124:	89 30       	cpi	r24, 0x09	; 9
 126:	30 f3       	brcs	.-52     	; 0xf4 <FindUnassignedLocation+0x78>
			(*col)++;
		}
		(*col)=0; // end of the row
		(*row)++;
	}
    return 0; // case that there is no unassigned values in the grid. 
 128:	80 e0       	ldi	r24, 0x00	; 0
}
 12a:	0f 90       	pop	r0
 12c:	0f 90       	pop	r0
 12e:	0f 90       	pop	r0
 130:	0f 90       	pop	r0
 132:	df 91       	pop	r29
 134:	cf 91       	pop	r28
 136:	08 95       	ret

00000138 <isSafe>:

	In case the safe flag is up after all the checks, which means that the conditions 
	have been met, the functions returns true. 
*/
uint8_t isSafe( uint8_t row,uint8_t col, uint8_t num)
{
 138:	cf 93       	push	r28
 13a:	df 93       	push	r29
 13c:	cd b7       	in	r28, 0x3d	; 61
 13e:	de b7       	in	r29, 0x3e	; 62
 140:	28 97       	sbiw	r28, 0x08	; 8
 142:	0f b6       	in	r0, 0x3f	; 63
 144:	f8 94       	cli
 146:	de bf       	out	0x3e, r29	; 62
 148:	0f be       	out	0x3f, r0	; 63
 14a:	cd bf       	out	0x3d, r28	; 61
 14c:	8e 83       	std	Y+6, r24	; 0x06
 14e:	6f 83       	std	Y+7, r22	; 0x07
 150:	48 87       	std	Y+8, r20	; 0x08
	//safe flag that is responsible of getting down if 
	//some of the below conditions are not met
	uint8_t safe=1; 
 152:	81 e0       	ldi	r24, 0x01	; 1
 154:	89 83       	std	Y+1, r24	; 0x01
	uint8_t tempCol;
	


	// row check 
	tempCol=0;
 156:	1b 82       	std	Y+3, r1	; 0x03
    while(tempCol<N && safe!=0){
 158:	1c c0       	rjmp	.+56     	; 0x192 <isSafe+0x5a>
		if (grid[row][tempCol] == num){
 15a:	8e 81       	ldd	r24, Y+6	; 0x06
 15c:	28 2f       	mov	r18, r24
 15e:	30 e0       	ldi	r19, 0x00	; 0
 160:	8b 81       	ldd	r24, Y+3	; 0x03
 162:	48 2f       	mov	r20, r24
 164:	50 e0       	ldi	r21, 0x00	; 0
 166:	c9 01       	movw	r24, r18
 168:	88 0f       	add	r24, r24
 16a:	99 1f       	adc	r25, r25
 16c:	88 0f       	add	r24, r24
 16e:	99 1f       	adc	r25, r25
 170:	88 0f       	add	r24, r24
 172:	99 1f       	adc	r25, r25
 174:	82 0f       	add	r24, r18
 176:	93 1f       	adc	r25, r19
 178:	84 0f       	add	r24, r20
 17a:	95 1f       	adc	r25, r21
 17c:	80 5a       	subi	r24, 0xA0	; 160
 17e:	9f 4f       	sbci	r25, 0xFF	; 255
 180:	fc 01       	movw	r30, r24
 182:	90 81       	ld	r25, Z
 184:	88 85       	ldd	r24, Y+8	; 0x08
 186:	98 17       	cp	r25, r24
 188:	09 f4       	brne	.+2      	; 0x18c <isSafe+0x54>
			safe=0; // case there is the same number in the same row
 18a:	19 82       	std	Y+1, r1	; 0x01
		}
		tempCol++;
 18c:	8b 81       	ldd	r24, Y+3	; 0x03
 18e:	8f 5f       	subi	r24, 0xFF	; 255
 190:	8b 83       	std	Y+3, r24	; 0x03
	


	// row check 
	tempCol=0;
    while(tempCol<N && safe!=0){
 192:	8b 81       	ldd	r24, Y+3	; 0x03
 194:	89 30       	cpi	r24, 0x09	; 9
 196:	18 f4       	brcc	.+6      	; 0x19e <isSafe+0x66>
 198:	89 81       	ldd	r24, Y+1	; 0x01
 19a:	88 23       	and	r24, r24
 19c:	f1 f6       	brne	.-68     	; 0x15a <isSafe+0x22>
		}
		tempCol++;
	}

	// column check
	tempRow=0;
 19e:	1a 82       	std	Y+2, r1	; 0x02
	while(tempRow<N && safe!=0){
 1a0:	1c c0       	rjmp	.+56     	; 0x1da <isSafe+0xa2>
		if (grid[tempRow][col] == num){
 1a2:	8a 81       	ldd	r24, Y+2	; 0x02
 1a4:	28 2f       	mov	r18, r24
 1a6:	30 e0       	ldi	r19, 0x00	; 0
 1a8:	8f 81       	ldd	r24, Y+7	; 0x07
 1aa:	48 2f       	mov	r20, r24
 1ac:	50 e0       	ldi	r21, 0x00	; 0
 1ae:	c9 01       	movw	r24, r18
 1b0:	88 0f       	add	r24, r24
 1b2:	99 1f       	adc	r25, r25
 1b4:	88 0f       	add	r24, r24
 1b6:	99 1f       	adc	r25, r25
 1b8:	88 0f       	add	r24, r24
 1ba:	99 1f       	adc	r25, r25
 1bc:	82 0f       	add	r24, r18
 1be:	93 1f       	adc	r25, r19
 1c0:	84 0f       	add	r24, r20
 1c2:	95 1f       	adc	r25, r21
 1c4:	80 5a       	subi	r24, 0xA0	; 160
 1c6:	9f 4f       	sbci	r25, 0xFF	; 255
 1c8:	fc 01       	movw	r30, r24
 1ca:	90 81       	ld	r25, Z
 1cc:	88 85       	ldd	r24, Y+8	; 0x08
 1ce:	98 17       	cp	r25, r24
 1d0:	09 f4       	brne	.+2      	; 0x1d4 <isSafe+0x9c>
			safe=0; // case there is the same number in the same column
 1d2:	19 82       	std	Y+1, r1	; 0x01
		}
		tempRow++;
 1d4:	8a 81       	ldd	r24, Y+2	; 0x02
 1d6:	8f 5f       	subi	r24, 0xFF	; 255
 1d8:	8a 83       	std	Y+2, r24	; 0x02
		tempCol++;
	}

	// column check
	tempRow=0;
	while(tempRow<N && safe!=0){
 1da:	8a 81       	ldd	r24, Y+2	; 0x02
 1dc:	89 30       	cpi	r24, 0x09	; 9
 1de:	18 f4       	brcc	.+6      	; 0x1e6 <isSafe+0xae>
 1e0:	89 81       	ldd	r24, Y+1	; 0x01
 1e2:	88 23       	and	r24, r24
 1e4:	f1 f6       	brne	.-68     	; 0x1a2 <isSafe+0x6a>
	}
	
	// sub-grid check
	
	//Take the relative position in the sub-grid.
	tempCol=col - col % 3;
 1e6:	2f 81       	ldd	r18, Y+7	; 0x07
 1e8:	8b ea       	ldi	r24, 0xAB	; 171
 1ea:	28 9f       	mul	r18, r24
 1ec:	81 2d       	mov	r24, r1
 1ee:	11 24       	eor	r1, r1
 1f0:	98 2f       	mov	r25, r24
 1f2:	96 95       	lsr	r25
 1f4:	89 2f       	mov	r24, r25
 1f6:	88 0f       	add	r24, r24
 1f8:	89 0f       	add	r24, r25
 1fa:	92 2f       	mov	r25, r18
 1fc:	98 1b       	sub	r25, r24
 1fe:	8f 81       	ldd	r24, Y+7	; 0x07
 200:	89 1b       	sub	r24, r25
 202:	8b 83       	std	Y+3, r24	; 0x03
	tempRow=row - row % 3;
 204:	2e 81       	ldd	r18, Y+6	; 0x06
 206:	8b ea       	ldi	r24, 0xAB	; 171
 208:	28 9f       	mul	r18, r24
 20a:	81 2d       	mov	r24, r1
 20c:	11 24       	eor	r1, r1
 20e:	98 2f       	mov	r25, r24
 210:	96 95       	lsr	r25
 212:	89 2f       	mov	r24, r25
 214:	88 0f       	add	r24, r24
 216:	89 0f       	add	r24, r25
 218:	92 2f       	mov	r25, r18
 21a:	98 1b       	sub	r25, r24
 21c:	8e 81       	ldd	r24, Y+6	; 0x06
 21e:	89 1b       	sub	r24, r25
 220:	8a 83       	std	Y+2, r24	; 0x02
	
	uint8_t boxRow=0;
 222:	1c 82       	std	Y+4, r1	; 0x04
	uint8_t boxCol=0;
 224:	1d 82       	std	Y+5, r1	; 0x05
	// check if there is the same number in the sub-grid
	while(boxRow<3 && safe!=0)
 226:	31 c0       	rjmp	.+98     	; 0x28a <__EEPROM_REGION_LENGTH__+0x8a>
	{
		boxCol=0;
 228:	1d 82       	std	Y+5, r1	; 0x05
		while(boxCol<3 && safe!=0)
 22a:	26 c0       	rjmp	.+76     	; 0x278 <__EEPROM_REGION_LENGTH__+0x78>
		{
			if (grid[boxRow + tempRow][boxCol + tempCol] == num)
 22c:	8c 81       	ldd	r24, Y+4	; 0x04
 22e:	28 2f       	mov	r18, r24
 230:	30 e0       	ldi	r19, 0x00	; 0
 232:	8a 81       	ldd	r24, Y+2	; 0x02
 234:	88 2f       	mov	r24, r24
 236:	90 e0       	ldi	r25, 0x00	; 0
 238:	28 0f       	add	r18, r24
 23a:	39 1f       	adc	r19, r25
 23c:	8d 81       	ldd	r24, Y+5	; 0x05
 23e:	48 2f       	mov	r20, r24
 240:	50 e0       	ldi	r21, 0x00	; 0
 242:	8b 81       	ldd	r24, Y+3	; 0x03
 244:	88 2f       	mov	r24, r24
 246:	90 e0       	ldi	r25, 0x00	; 0
 248:	48 0f       	add	r20, r24
 24a:	59 1f       	adc	r21, r25
 24c:	c9 01       	movw	r24, r18
 24e:	88 0f       	add	r24, r24
 250:	99 1f       	adc	r25, r25
 252:	88 0f       	add	r24, r24
 254:	99 1f       	adc	r25, r25
 256:	88 0f       	add	r24, r24
 258:	99 1f       	adc	r25, r25
 25a:	82 0f       	add	r24, r18
 25c:	93 1f       	adc	r25, r19
 25e:	84 0f       	add	r24, r20
 260:	95 1f       	adc	r25, r21
 262:	80 5a       	subi	r24, 0xA0	; 160
 264:	9f 4f       	sbci	r25, 0xFF	; 255
 266:	fc 01       	movw	r30, r24
 268:	90 81       	ld	r25, Z
 26a:	88 85       	ldd	r24, Y+8	; 0x08
 26c:	98 17       	cp	r25, r24
 26e:	09 f4       	brne	.+2      	; 0x272 <__EEPROM_REGION_LENGTH__+0x72>
			{
				safe=0;
 270:	19 82       	std	Y+1, r1	; 0x01
			}
			boxCol++;
 272:	8d 81       	ldd	r24, Y+5	; 0x05
 274:	8f 5f       	subi	r24, 0xFF	; 255
 276:	8d 83       	std	Y+5, r24	; 0x05
	uint8_t boxCol=0;
	// check if there is the same number in the sub-grid
	while(boxRow<3 && safe!=0)
	{
		boxCol=0;
		while(boxCol<3 && safe!=0)
 278:	8d 81       	ldd	r24, Y+5	; 0x05
 27a:	83 30       	cpi	r24, 0x03	; 3
 27c:	18 f4       	brcc	.+6      	; 0x284 <__EEPROM_REGION_LENGTH__+0x84>
 27e:	89 81       	ldd	r24, Y+1	; 0x01
 280:	88 23       	and	r24, r24
 282:	a1 f6       	brne	.-88     	; 0x22c <__EEPROM_REGION_LENGTH__+0x2c>
			{
				safe=0;
			}
			boxCol++;
		}
		boxRow++;
 284:	8c 81       	ldd	r24, Y+4	; 0x04
 286:	8f 5f       	subi	r24, 0xFF	; 255
 288:	8c 83       	std	Y+4, r24	; 0x04
	tempRow=row - row % 3;
	
	uint8_t boxRow=0;
	uint8_t boxCol=0;
	// check if there is the same number in the sub-grid
	while(boxRow<3 && safe!=0)
 28a:	8c 81       	ldd	r24, Y+4	; 0x04
 28c:	83 30       	cpi	r24, 0x03	; 3
 28e:	18 f4       	brcc	.+6      	; 0x296 <__EEPROM_REGION_LENGTH__+0x96>
 290:	89 81       	ldd	r24, Y+1	; 0x01
 292:	88 23       	and	r24, r24
 294:	49 f6       	brne	.-110    	; 0x228 <__EEPROM_REGION_LENGTH__+0x28>
			}
			boxCol++;
		}
		boxRow++;
	}
    return safe && grid[row][col] == UNASSIGNED;
 296:	89 81       	ldd	r24, Y+1	; 0x01
 298:	88 23       	and	r24, r24
 29a:	d1 f0       	breq	.+52     	; 0x2d0 <__EEPROM_REGION_LENGTH__+0xd0>
 29c:	8e 81       	ldd	r24, Y+6	; 0x06
 29e:	28 2f       	mov	r18, r24
 2a0:	30 e0       	ldi	r19, 0x00	; 0
 2a2:	8f 81       	ldd	r24, Y+7	; 0x07
 2a4:	48 2f       	mov	r20, r24
 2a6:	50 e0       	ldi	r21, 0x00	; 0
 2a8:	c9 01       	movw	r24, r18
 2aa:	88 0f       	add	r24, r24
 2ac:	99 1f       	adc	r25, r25
 2ae:	88 0f       	add	r24, r24
 2b0:	99 1f       	adc	r25, r25
 2b2:	88 0f       	add	r24, r24
 2b4:	99 1f       	adc	r25, r25
 2b6:	82 0f       	add	r24, r18
 2b8:	93 1f       	adc	r25, r19
 2ba:	84 0f       	add	r24, r20
 2bc:	95 1f       	adc	r25, r21
 2be:	80 5a       	subi	r24, 0xA0	; 160
 2c0:	9f 4f       	sbci	r25, 0xFF	; 255
 2c2:	fc 01       	movw	r30, r24
 2c4:	80 81       	ld	r24, Z
 2c6:	88 23       	and	r24, r24
 2c8:	19 f4       	brne	.+6      	; 0x2d0 <__EEPROM_REGION_LENGTH__+0xd0>
 2ca:	81 e0       	ldi	r24, 0x01	; 1
 2cc:	90 e0       	ldi	r25, 0x00	; 0
 2ce:	02 c0       	rjmp	.+4      	; 0x2d4 <__EEPROM_REGION_LENGTH__+0xd4>
 2d0:	80 e0       	ldi	r24, 0x00	; 0
 2d2:	90 e0       	ldi	r25, 0x00	; 0
}
 2d4:	28 96       	adiw	r28, 0x08	; 8
 2d6:	0f b6       	in	r0, 0x3f	; 63
 2d8:	f8 94       	cli
 2da:	de bf       	out	0x3e, r29	; 62
 2dc:	0f be       	out	0x3f, r0	; 63
 2de:	cd bf       	out	0x3d, r28	; 61
 2e0:	df 91       	pop	r29
 2e2:	cf 91       	pop	r28
 2e4:	08 95       	ret

000002e6 <SolveSudoku>:
	in the grid and starts testing possible numbers there. If a number can be assigned 
	there the function calls herself to repeat the process. if not the function does not 
	assign the number and tries the next one.
*/
uint8_t SolveSudoku()
{
 2e6:	cf 93       	push	r28
 2e8:	df 93       	push	r29
 2ea:	00 d0       	rcall	.+0      	; 0x2ec <SolveSudoku+0x6>
 2ec:	1f 92       	push	r1
 2ee:	cd b7       	in	r28, 0x3d	; 61
 2f0:	de b7       	in	r29, 0x3e	; 62
     uint8_t row;
	 uint8_t col;
    // Check If there is no unassigned
    // location, we are done
    if (!FindUnassignedLocation(&row,&col) || play==0)
 2f2:	9e 01       	movw	r18, r28
 2f4:	2d 5f       	subi	r18, 0xFD	; 253
 2f6:	3f 4f       	sbci	r19, 0xFF	; 255
 2f8:	ce 01       	movw	r24, r28
 2fa:	02 96       	adiw	r24, 0x02	; 2
 2fc:	b9 01       	movw	r22, r18
 2fe:	0e 94 3e 00 	call	0x7c	; 0x7c <FindUnassignedLocation>
 302:	88 23       	and	r24, r24
 304:	21 f0       	breq	.+8      	; 0x30e <SolveSudoku+0x28>
 306:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <play>
 30a:	88 23       	and	r24, r24
 30c:	11 f4       	brne	.+4      	; 0x312 <SolveSudoku+0x2c>
        return 1; // success!
 30e:	81 e0       	ldi	r24, 0x01	; 1
 310:	4d c0       	rjmp	.+154    	; 0x3ac <SolveSudoku+0xc6>
   //Consider digits 1 to 9
	progress++;
 312:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <progress>
 316:	8f 5f       	subi	r24, 0xFF	; 255
 318:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <progress>
    for (uint8_t num = 1; num <= 9; num++)
 31c:	81 e0       	ldi	r24, 0x01	; 1
 31e:	89 83       	std	Y+1, r24	; 0x01
 320:	3c c0       	rjmp	.+120    	; 0x39a <SolveSudoku+0xb4>
    {

        // Check if there is a possible match
        if (isSafe( row, col, num))
 322:	9b 81       	ldd	r25, Y+3	; 0x03
 324:	8a 81       	ldd	r24, Y+2	; 0x02
 326:	49 81       	ldd	r20, Y+1	; 0x01
 328:	69 2f       	mov	r22, r25
 32a:	0e 94 9c 00 	call	0x138	; 0x138 <isSafe>
 32e:	88 23       	and	r24, r24
 330:	89 f1       	breq	.+98     	; 0x394 <SolveSudoku+0xae>
        {

            // Make tentative assignment
            grid[row][col] = num;
 332:	8a 81       	ldd	r24, Y+2	; 0x02
 334:	28 2f       	mov	r18, r24
 336:	30 e0       	ldi	r19, 0x00	; 0
 338:	8b 81       	ldd	r24, Y+3	; 0x03
 33a:	48 2f       	mov	r20, r24
 33c:	50 e0       	ldi	r21, 0x00	; 0
 33e:	c9 01       	movw	r24, r18
 340:	88 0f       	add	r24, r24
 342:	99 1f       	adc	r25, r25
 344:	88 0f       	add	r24, r24
 346:	99 1f       	adc	r25, r25
 348:	88 0f       	add	r24, r24
 34a:	99 1f       	adc	r25, r25
 34c:	82 0f       	add	r24, r18
 34e:	93 1f       	adc	r25, r19
 350:	84 0f       	add	r24, r20
 352:	95 1f       	adc	r25, r21
 354:	80 5a       	subi	r24, 0xA0	; 160
 356:	9f 4f       	sbci	r25, 0xFF	; 255
 358:	29 81       	ldd	r18, Y+1	; 0x01
 35a:	fc 01       	movw	r30, r24
 35c:	20 83       	st	Z, r18

            // Return, if success!
            if (SolveSudoku()){
 35e:	0e 94 73 01 	call	0x2e6	; 0x2e6 <SolveSudoku>
 362:	88 23       	and	r24, r24
 364:	11 f0       	breq	.+4      	; 0x36a <SolveSudoku+0x84>
                return 1;
 366:	81 e0       	ldi	r24, 0x01	; 1
 368:	21 c0       	rjmp	.+66     	; 0x3ac <SolveSudoku+0xc6>
			}
            // Failure, unmake & try again
            grid[row][col] = UNASSIGNED;
 36a:	8a 81       	ldd	r24, Y+2	; 0x02
 36c:	28 2f       	mov	r18, r24
 36e:	30 e0       	ldi	r19, 0x00	; 0
 370:	8b 81       	ldd	r24, Y+3	; 0x03
 372:	48 2f       	mov	r20, r24
 374:	50 e0       	ldi	r21, 0x00	; 0
 376:	c9 01       	movw	r24, r18
 378:	88 0f       	add	r24, r24
 37a:	99 1f       	adc	r25, r25
 37c:	88 0f       	add	r24, r24
 37e:	99 1f       	adc	r25, r25
 380:	88 0f       	add	r24, r24
 382:	99 1f       	adc	r25, r25
 384:	82 0f       	add	r24, r18
 386:	93 1f       	adc	r25, r19
 388:	84 0f       	add	r24, r20
 38a:	95 1f       	adc	r25, r21
 38c:	80 5a       	subi	r24, 0xA0	; 160
 38e:	9f 4f       	sbci	r25, 0xFF	; 255
 390:	fc 01       	movw	r30, r24
 392:	10 82       	st	Z, r1
    // location, we are done
    if (!FindUnassignedLocation(&row,&col) || play==0)
        return 1; // success!
   //Consider digits 1 to 9
	progress++;
    for (uint8_t num = 1; num <= 9; num++)
 394:	89 81       	ldd	r24, Y+1	; 0x01
 396:	8f 5f       	subi	r24, 0xFF	; 255
 398:	89 83       	std	Y+1, r24	; 0x01
 39a:	89 81       	ldd	r24, Y+1	; 0x01
 39c:	8a 30       	cpi	r24, 0x0A	; 10
 39e:	08 f2       	brcs	.-126    	; 0x322 <SolveSudoku+0x3c>
            grid[row][col] = UNASSIGNED;
        }
    }

    // This triggers backtracking
	progress--;
 3a0:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <progress>
 3a4:	81 50       	subi	r24, 0x01	; 1
 3a6:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <progress>
    return 0;
 3aa:	80 e0       	ldi	r24, 0x00	; 0
}
 3ac:	0f 90       	pop	r0
 3ae:	0f 90       	pop	r0
 3b0:	0f 90       	pop	r0
 3b2:	df 91       	pop	r29
 3b4:	cf 91       	pop	r28
 3b6:	08 95       	ret

000003b8 <putC>:
	FUNCTIONALITY:
	The function is used for I/O. It waits until UDRE flag is up. (the flag is located
	in the UCSRA). When the flag is up, it writes the writeChar var into the UDR in order
	to be exported.
*/
void putC(uint8_t writeChar){
 3b8:	cf 93       	push	r28
 3ba:	df 93       	push	r29
 3bc:	1f 92       	push	r1
 3be:	cd b7       	in	r28, 0x3d	; 61
 3c0:	de b7       	in	r29, 0x3e	; 62
 3c2:	89 83       	std	Y+1, r24	; 0x01
	while(!((UCSRA & 0x20)==0x20)){}  //; wait until data register empty
 3c4:	00 00       	nop
 3c6:	8b e2       	ldi	r24, 0x2B	; 43
 3c8:	90 e0       	ldi	r25, 0x00	; 0
 3ca:	fc 01       	movw	r30, r24
 3cc:	80 81       	ld	r24, Z
 3ce:	88 2f       	mov	r24, r24
 3d0:	90 e0       	ldi	r25, 0x00	; 0
 3d2:	80 72       	andi	r24, 0x20	; 32
 3d4:	99 27       	eor	r25, r25
 3d6:	89 2b       	or	r24, r25
 3d8:	b1 f3       	breq	.-20     	; 0x3c6 <putC+0xe>
	UDR=writeChar;
 3da:	8c e2       	ldi	r24, 0x2C	; 44
 3dc:	90 e0       	ldi	r25, 0x00	; 0
 3de:	29 81       	ldd	r18, Y+1	; 0x01
 3e0:	fc 01       	movw	r30, r24
 3e2:	20 83       	st	Z, r18
	return;
 3e4:	00 00       	nop
}
 3e6:	0f 90       	pop	r0
 3e8:	df 91       	pop	r29
 3ea:	cf 91       	pop	r28
 3ec:	08 95       	ret

000003ee <getC>:
	be able to process the input from the I/O, the function stores 
	the contents of the UDR into a buffer as long as the char is 
	not the <LF> ascii value. Then returns the char the has been 
	read.
*/
char getC(){
 3ee:	cf 93       	push	r28
 3f0:	df 93       	push	r29
 3f2:	1f 92       	push	r1
 3f4:	cd b7       	in	r28, 0x3d	; 61
 3f6:	de b7       	in	r29, 0x3e	; 62
	char  readChar;   //read char from UART
	readChar=UDR;
 3f8:	8c e2       	ldi	r24, 0x2C	; 44
 3fa:	90 e0       	ldi	r25, 0x00	; 0
 3fc:	fc 01       	movw	r30, r24
 3fe:	80 81       	ld	r24, Z
 400:	89 83       	std	Y+1, r24	; 0x01
	if(readChar!=0x0D){
 402:	89 81       	ldd	r24, Y+1	; 0x01
 404:	8d 30       	cpi	r24, 0x0D	; 13
 406:	71 f0       	breq	.+28     	; 0x424 <__DATA_REGION_LENGTH__+0x24>
		readWord[letter]=readChar;
 408:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <letter>
 40c:	88 2f       	mov	r24, r24
 40e:	90 e0       	ldi	r25, 0x00	; 0
 410:	8f 54       	subi	r24, 0x4F	; 79
 412:	9f 4f       	sbci	r25, 0xFF	; 255
 414:	29 81       	ldd	r18, Y+1	; 0x01
 416:	fc 01       	movw	r30, r24
 418:	20 83       	st	Z, r18
		letter++;
 41a:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <letter>
 41e:	8f 5f       	subi	r24, 0xFF	; 255
 420:	80 93 b9 00 	sts	0x00B9, r24	; 0x8000b9 <letter>
	}
	return readChar;
 424:	89 81       	ldd	r24, Y+1	; 0x01
}
 426:	0f 90       	pop	r0
 428:	df 91       	pop	r29
 42a:	cf 91       	pop	r28
 42c:	08 95       	ret

0000042e <__vector_6>:

////////////////////////
//  ISR FOR TIMER_CMP //
////////////////////////
ISR(TIMER1_COMPA_vect, ISR_NAKED) {
	asm("  in r0,__SREG__ \n\t\
 42e:	0f b6       	in	r0, 0x3f	; 63
 430:	0f 92       	push	r0
 432:	00 24       	eor	r0, r0
 434:	0f 93       	push	r16
 436:	1f 93       	push	r17
 438:	2f 93       	push	r18
 43a:	3f 93       	push	r19
 43c:	4f 93       	push	r20
 43e:	5f 93       	push	r21
 440:	6f 93       	push	r22
 442:	7f 93       	push	r23
 444:	8f 93       	push	r24
 446:	9f 93       	push	r25
 448:	af 93       	push	r26
 44a:	bf 93       	push	r27
 44c:	cf 93       	push	r28
 44e:	df 93       	push	r29
 450:	ef 93       	push	r30
 452:	ff 93       	push	r31
	push r27 \n\t\
	push r28 \n\t\
	push r29 \n\t\
	push r30 \n\t\
	push r31");
	if(progress>79){PORTB=255;}    // activate LEDs accordingly with progress 
 454:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <progress>
 458:	80 35       	cpi	r24, 0x50	; 80
 45a:	30 f0       	brcs	.+12     	; 0x468 <__stack+0x9>
 45c:	88 e3       	ldi	r24, 0x38	; 56
 45e:	90 e0       	ldi	r25, 0x00	; 0
 460:	2f ef       	ldi	r18, 0xFF	; 255
 462:	fc 01       	movw	r30, r24
 464:	20 83       	st	Z, r18
 466:	45 c0       	rjmp	.+138    	; 0x4f2 <__stack+0x93>
	else if(progress>69){PORTB=127;}
 468:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <progress>
 46c:	86 34       	cpi	r24, 0x46	; 70
 46e:	30 f0       	brcs	.+12     	; 0x47c <__stack+0x1d>
 470:	88 e3       	ldi	r24, 0x38	; 56
 472:	90 e0       	ldi	r25, 0x00	; 0
 474:	2f e7       	ldi	r18, 0x7F	; 127
 476:	fc 01       	movw	r30, r24
 478:	20 83       	st	Z, r18
 47a:	3b c0       	rjmp	.+118    	; 0x4f2 <__stack+0x93>
	else if(progress>59){PORTB=63;}	
 47c:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <progress>
 480:	8c 33       	cpi	r24, 0x3C	; 60
 482:	30 f0       	brcs	.+12     	; 0x490 <__stack+0x31>
 484:	88 e3       	ldi	r24, 0x38	; 56
 486:	90 e0       	ldi	r25, 0x00	; 0
 488:	2f e3       	ldi	r18, 0x3F	; 63
 48a:	fc 01       	movw	r30, r24
 48c:	20 83       	st	Z, r18
 48e:	31 c0       	rjmp	.+98     	; 0x4f2 <__stack+0x93>
	else if(progress>49){PORTB=31;}
 490:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <progress>
 494:	82 33       	cpi	r24, 0x32	; 50
 496:	30 f0       	brcs	.+12     	; 0x4a4 <__stack+0x45>
 498:	88 e3       	ldi	r24, 0x38	; 56
 49a:	90 e0       	ldi	r25, 0x00	; 0
 49c:	2f e1       	ldi	r18, 0x1F	; 31
 49e:	fc 01       	movw	r30, r24
 4a0:	20 83       	st	Z, r18
 4a2:	27 c0       	rjmp	.+78     	; 0x4f2 <__stack+0x93>
	else if(progress>39){PORTB=15;}
 4a4:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <progress>
 4a8:	88 32       	cpi	r24, 0x28	; 40
 4aa:	30 f0       	brcs	.+12     	; 0x4b8 <__stack+0x59>
 4ac:	88 e3       	ldi	r24, 0x38	; 56
 4ae:	90 e0       	ldi	r25, 0x00	; 0
 4b0:	2f e0       	ldi	r18, 0x0F	; 15
 4b2:	fc 01       	movw	r30, r24
 4b4:	20 83       	st	Z, r18
 4b6:	1d c0       	rjmp	.+58     	; 0x4f2 <__stack+0x93>
	else if(progress>29){PORTB=7;}
 4b8:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <progress>
 4bc:	8e 31       	cpi	r24, 0x1E	; 30
 4be:	30 f0       	brcs	.+12     	; 0x4cc <__stack+0x6d>
 4c0:	88 e3       	ldi	r24, 0x38	; 56
 4c2:	90 e0       	ldi	r25, 0x00	; 0
 4c4:	27 e0       	ldi	r18, 0x07	; 7
 4c6:	fc 01       	movw	r30, r24
 4c8:	20 83       	st	Z, r18
 4ca:	13 c0       	rjmp	.+38     	; 0x4f2 <__stack+0x93>
	else if(progress>19){PORTB=3;}
 4cc:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <progress>
 4d0:	84 31       	cpi	r24, 0x14	; 20
 4d2:	30 f0       	brcs	.+12     	; 0x4e0 <__stack+0x81>
 4d4:	88 e3       	ldi	r24, 0x38	; 56
 4d6:	90 e0       	ldi	r25, 0x00	; 0
 4d8:	23 e0       	ldi	r18, 0x03	; 3
 4da:	fc 01       	movw	r30, r24
 4dc:	20 83       	st	Z, r18
 4de:	09 c0       	rjmp	.+18     	; 0x4f2 <__stack+0x93>
	else if(progress>9){PORTB=1;}  
 4e0:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <progress>
 4e4:	8a 30       	cpi	r24, 0x0A	; 10
 4e6:	28 f0       	brcs	.+10     	; 0x4f2 <__stack+0x93>
 4e8:	88 e3       	ldi	r24, 0x38	; 56
 4ea:	90 e0       	ldi	r25, 0x00	; 0
 4ec:	21 e0       	ldi	r18, 0x01	; 1
 4ee:	fc 01       	movw	r30, r24
 4f0:	20 83       	st	Z, r18
	TCNT1H=0;					 // Restart TIMER
 4f2:	8d e4       	ldi	r24, 0x4D	; 77
 4f4:	90 e0       	ldi	r25, 0x00	; 0
 4f6:	fc 01       	movw	r30, r24
 4f8:	10 82       	st	Z, r1
	TCNT1L=0;					 // Restart TIMER
 4fa:	8c e4       	ldi	r24, 0x4C	; 76
 4fc:	90 e0       	ldi	r25, 0x00	; 0
 4fe:	fc 01       	movw	r30, r24
 500:	10 82       	st	Z, r1
	asm(" pop r31\n\t\
 502:	ff 91       	pop	r31
 504:	ef 91       	pop	r30
 506:	df 91       	pop	r29
 508:	cf 91       	pop	r28
 50a:	bf 91       	pop	r27
 50c:	af 91       	pop	r26
 50e:	9f 91       	pop	r25
 510:	8f 91       	pop	r24
 512:	7f 91       	pop	r23
 514:	6f 91       	pop	r22
 516:	5f 91       	pop	r21
 518:	4f 91       	pop	r20
 51a:	3f 91       	pop	r19
 51c:	2f 91       	pop	r18
 51e:	1f 91       	pop	r17
 520:	0f 91       	pop	r16
 522:	0f 90       	pop	r0
 524:	0f be       	out	0x3f, r0	; 63
 526:	00 24       	eor	r0, r0
	pop r17 \n\t\
	pop r16 \n\t\
	pop r0	 \n\t\
	out __SREG__,r0 \n\t\
	clr r0");
	reti();
 528:	18 95       	reti
	...

0000052c <__vector_11>:
////////////////////////
//  ISR FOR USART     //
////////////////////////

ISR(USART_RXC_vect, ISR_NAKED){
	asm("  in r0,__SREG__ \n\t\
 52c:	0f b6       	in	r0, 0x3f	; 63
 52e:	0f 92       	push	r0
 530:	00 24       	eor	r0, r0
 532:	0f 93       	push	r16
 534:	1f 93       	push	r17
 536:	2f 93       	push	r18
 538:	3f 93       	push	r19
 53a:	4f 93       	push	r20
 53c:	5f 93       	push	r21
 53e:	6f 93       	push	r22
 540:	7f 93       	push	r23
 542:	8f 93       	push	r24
 544:	9f 93       	push	r25
 546:	af 93       	push	r26
 548:	bf 93       	push	r27
 54a:	cf 93       	push	r28
 54c:	df 93       	push	r29
 54e:	ef 93       	push	r30
 550:	ff 93       	push	r31
		   push r27 \n\t\
		   push r28 \n\t\
		   push r29 \n\t\
		   push r30 \n\t\
		   push r31");
	char readChar=0;
 552:	10 e0       	ldi	r17, 0x00	; 0
	while((UCSRA & 0x80) == 0x80){  // while RXC==1 (of UCSRA) read char
 554:	03 c0       	rjmp	.+6      	; 0x55c <__vector_11+0x30>
		readChar=getC();
 556:	0e 94 f7 01 	call	0x3ee	; 0x3ee <getC>
 55a:	18 2f       	mov	r17, r24
		   push r28 \n\t\
		   push r29 \n\t\
		   push r30 \n\t\
		   push r31");
	char readChar=0;
	while((UCSRA & 0x80) == 0x80){  // while RXC==1 (of UCSRA) read char
 55c:	8b e2       	ldi	r24, 0x2B	; 43
 55e:	90 e0       	ldi	r25, 0x00	; 0
 560:	fc 01       	movw	r30, r24
 562:	80 81       	ld	r24, Z
 564:	88 23       	and	r24, r24
 566:	bc f3       	brlt	.-18     	; 0x556 <__vector_11+0x2a>
		readChar=getC();
	}
		if(readChar==0x0A){ // if LF received send OK;
 568:	1a 30       	cpi	r17, 0x0A	; 10
 56a:	09 f0       	breq	.+2      	; 0x56e <__vector_11+0x42>
 56c:	61 c1       	rjmp	.+706    	; 0x830 <__vector_11+0x304>
			if(readWord[0]=='A'){ // if command = AT send ok
 56e:	80 91 b1 00 	lds	r24, 0x00B1	; 0x8000b1 <readWord>
 572:	81 34       	cpi	r24, 0x41	; 65
 574:	69 f4       	brne	.+26     	; 0x590 <__vector_11+0x64>
				putC('O');        // send letter O
 576:	8f e4       	ldi	r24, 0x4F	; 79
 578:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <putC>
				putC('K');        // send letter K
 57c:	8b e4       	ldi	r24, 0x4B	; 75
 57e:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <putC>
				putC(0x0D);         // send letter CR
 582:	8d e0       	ldi	r24, 0x0D	; 13
 584:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <putC>
				putC(0x0A);         // send letter LF
 588:	8a e0       	ldi	r24, 0x0A	; 10
 58a:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <putC>
 58e:	41 c1       	rjmp	.+642    	; 0x812 <__vector_11+0x2e6>
			}
			else if(readWord[0]=='C'){  //set grid=0 if readchar==C
 590:	80 91 b1 00 	lds	r24, 0x00B1	; 0x8000b1 <readWord>
 594:	83 34       	cpi	r24, 0x43	; 67
 596:	d1 f5       	brne	.+116    	; 0x60c <__vector_11+0xe0>
				uint8_t  i=0;
 598:	10 e0       	ldi	r17, 0x00	; 0
				progress=0;
 59a:	10 92 bc 00 	sts	0x00BC, r1	; 0x8000bc <progress>
				sendXpos=0;
 59e:	10 92 ba 00 	sts	0x00BA, r1	; 0x8000ba <sendXpos>
				sendYpos=0;
 5a2:	10 92 bd 00 	sts	0x00BD, r1	; 0x8000bd <sendYpos>
				PORTB=0;
 5a6:	88 e3       	ldi	r24, 0x38	; 56
 5a8:	90 e0       	ldi	r25, 0x00	; 0
 5aa:	fc 01       	movw	r30, r24
 5ac:	10 82       	st	Z, r1
				i=0;
 5ae:	10 e0       	ldi	r17, 0x00	; 0
				uint8_t  j=0;
 5b0:	00 e0       	ldi	r16, 0x00	; 0
				while(i<N){     // set grid array to 0
 5b2:	1d c0       	rjmp	.+58     	; 0x5ee <__vector_11+0xc2>
					while(j<N){
 5b4:	16 c0       	rjmp	.+44     	; 0x5e2 <__vector_11+0xb6>
						grid[i][j]=0;
 5b6:	21 2f       	mov	r18, r17
 5b8:	30 e0       	ldi	r19, 0x00	; 0
 5ba:	40 2f       	mov	r20, r16
 5bc:	50 e0       	ldi	r21, 0x00	; 0
 5be:	c9 01       	movw	r24, r18
 5c0:	88 0f       	add	r24, r24
 5c2:	99 1f       	adc	r25, r25
 5c4:	88 0f       	add	r24, r24
 5c6:	99 1f       	adc	r25, r25
 5c8:	88 0f       	add	r24, r24
 5ca:	99 1f       	adc	r25, r25
 5cc:	82 0f       	add	r24, r18
 5ce:	93 1f       	adc	r25, r19
 5d0:	84 0f       	add	r24, r20
 5d2:	95 1f       	adc	r25, r21
 5d4:	80 5a       	subi	r24, 0xA0	; 160
 5d6:	9f 4f       	sbci	r25, 0xFF	; 255
 5d8:	fc 01       	movw	r30, r24
 5da:	10 82       	st	Z, r1
						j++;
 5dc:	80 2f       	mov	r24, r16
 5de:	01 e0       	ldi	r16, 0x01	; 1
 5e0:	08 0f       	add	r16, r24
				sendYpos=0;
				PORTB=0;
				i=0;
				uint8_t  j=0;
				while(i<N){     // set grid array to 0
					while(j<N){
 5e2:	09 30       	cpi	r16, 0x09	; 9
 5e4:	40 f3       	brcs	.-48     	; 0x5b6 <__vector_11+0x8a>
						grid[i][j]=0;
						j++;
					}
					j=0;
 5e6:	00 e0       	ldi	r16, 0x00	; 0
					i++;
 5e8:	81 2f       	mov	r24, r17
 5ea:	11 e0       	ldi	r17, 0x01	; 1
 5ec:	18 0f       	add	r17, r24
				sendXpos=0;
				sendYpos=0;
				PORTB=0;
				i=0;
				uint8_t  j=0;
				while(i<N){     // set grid array to 0
 5ee:	19 30       	cpi	r17, 0x09	; 9
 5f0:	08 f3       	brcs	.-62     	; 0x5b4 <__vector_11+0x88>
						j++;
					}
					j=0;
					i++;
				}
				putC('O');        // send letter O
 5f2:	8f e4       	ldi	r24, 0x4F	; 79
 5f4:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <putC>
				putC('K');        // send letter K
 5f8:	8b e4       	ldi	r24, 0x4B	; 75
 5fa:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <putC>
				putC(0x0D);         // send letter CR
 5fe:	8d e0       	ldi	r24, 0x0D	; 13
 600:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <putC>
				putC(0x0A);         // send letter LF
 604:	8a e0       	ldi	r24, 0x0A	; 10
 606:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <putC>
 60a:	03 c1       	rjmp	.+518    	; 0x812 <__vector_11+0x2e6>
			}
			else if(readWord[0]=='N'){  // command is N read number of grid
 60c:	80 91 b1 00 	lds	r24, 0x00B1	; 0x8000b1 <readWord>
 610:	8e 34       	cpi	r24, 0x4E	; 78
 612:	99 f5       	brne	.+102    	; 0x67a <__vector_11+0x14e>
				grid[readWord[1]-48-1][readWord[2]-48-1]=readWord[3]-48; // -48 to convert ascii to int
 614:	80 91 b2 00 	lds	r24, 0x00B2	; 0x8000b2 <readWord+0x1>
 618:	88 2f       	mov	r24, r24
 61a:	90 e0       	ldi	r25, 0x00	; 0
 61c:	9c 01       	movw	r18, r24
 61e:	21 53       	subi	r18, 0x31	; 49
 620:	31 09       	sbc	r19, r1
 622:	80 91 b3 00 	lds	r24, 0x00B3	; 0x8000b3 <readWord+0x2>
 626:	88 2f       	mov	r24, r24
 628:	90 e0       	ldi	r25, 0x00	; 0
 62a:	ac 01       	movw	r20, r24
 62c:	41 53       	subi	r20, 0x31	; 49
 62e:	51 09       	sbc	r21, r1
 630:	80 91 b4 00 	lds	r24, 0x00B4	; 0x8000b4 <readWord+0x3>
 634:	60 ed       	ldi	r22, 0xD0	; 208
 636:	68 0f       	add	r22, r24
 638:	c9 01       	movw	r24, r18
 63a:	88 0f       	add	r24, r24
 63c:	99 1f       	adc	r25, r25
 63e:	88 0f       	add	r24, r24
 640:	99 1f       	adc	r25, r25
 642:	88 0f       	add	r24, r24
 644:	99 1f       	adc	r25, r25
 646:	82 0f       	add	r24, r18
 648:	93 1f       	adc	r25, r19
 64a:	84 0f       	add	r24, r20
 64c:	95 1f       	adc	r25, r21
 64e:	80 5a       	subi	r24, 0xA0	; 160
 650:	9f 4f       	sbci	r25, 0xFF	; 255
 652:	fc 01       	movw	r30, r24
 654:	60 83       	st	Z, r22
				progress++;
 656:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <progress>
 65a:	8f 5f       	subi	r24, 0xFF	; 255
 65c:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <progress>
				putC('O');        // send letter O
 660:	8f e4       	ldi	r24, 0x4F	; 79
 662:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <putC>
				putC('K');        // send letter K
 666:	8b e4       	ldi	r24, 0x4B	; 75
 668:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <putC>
				putC(0x0D);         // send letter CR
 66c:	8d e0       	ldi	r24, 0x0D	; 13
 66e:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <putC>
				putC(0x0A);         // send letter LF
 672:	8a e0       	ldi	r24, 0x0A	; 10
 674:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <putC>
 678:	cc c0       	rjmp	.+408    	; 0x812 <__vector_11+0x2e6>
			}
			else if(readWord[0]=='P'){  //If command is P set flag play =1 to start solving 
 67a:	80 91 b1 00 	lds	r24, 0x00B1	; 0x8000b1 <readWord>
 67e:	80 35       	cpi	r24, 0x50	; 80
 680:	81 f4       	brne	.+32     	; 0x6a2 <__vector_11+0x176>
				play=1;
 682:	81 e0       	ldi	r24, 0x01	; 1
 684:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <play>
				putC('O');        // send letter O
 688:	8f e4       	ldi	r24, 0x4F	; 79
 68a:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <putC>
				putC('K');        // send letter K
 68e:	8b e4       	ldi	r24, 0x4B	; 75
 690:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <putC>
				putC(0x0D);         // send letter CR
 694:	8d e0       	ldi	r24, 0x0D	; 13
 696:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <putC>
				putC(0x0A);         // send letter LF
 69a:	8a e0       	ldi	r24, 0x0A	; 10
 69c:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <putC>
 6a0:	b8 c0       	rjmp	.+368    	; 0x812 <__vector_11+0x2e6>
			}
			else if(readWord[0]=='S'){  //if command is S send the first number of grid 
 6a2:	80 91 b1 00 	lds	r24, 0x00B1	; 0x8000b1 <readWord>
 6a6:	83 35       	cpi	r24, 0x53	; 83
 6a8:	d1 f4       	brne	.+52     	; 0x6de <__vector_11+0x1b2>
				putC('N');				  // send letter N
 6aa:	8e e4       	ldi	r24, 0x4E	; 78
 6ac:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <putC>
				putC('1');				  // send position X=0
 6b0:	81 e3       	ldi	r24, 0x31	; 49
 6b2:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <putC>
				putC('1');				  // send position Y=0
 6b6:	81 e3       	ldi	r24, 0x31	; 49
 6b8:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <putC>
				putC(grid[0][0]+48);  // send first number of grid
 6bc:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 6c0:	80 5d       	subi	r24, 0xD0	; 208
 6c2:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <putC>
				putC(0x0D);               // send letter CR
 6c6:	8d e0       	ldi	r24, 0x0D	; 13
 6c8:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <putC>
				putC(0x0A);               // send letter LF
 6cc:	8a e0       	ldi	r24, 0x0A	; 10
 6ce:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <putC>
				sendXpos=0;
 6d2:	10 92 ba 00 	sts	0x00BA, r1	; 0x8000ba <sendXpos>
				sendYpos=1;
 6d6:	81 e0       	ldi	r24, 0x01	; 1
 6d8:	80 93 bd 00 	sts	0x00BD, r24	; 0x8000bd <sendYpos>
 6dc:	9a c0       	rjmp	.+308    	; 0x812 <__vector_11+0x2e6>
			}	
			else if(readWord[0]=='T'){  
 6de:	80 91 b1 00 	lds	r24, 0x00B1	; 0x8000b1 <readWord>
 6e2:	84 35       	cpi	r24, 0x54	; 84
 6e4:	09 f0       	breq	.+2      	; 0x6e8 <__vector_11+0x1bc>
 6e6:	4d c0       	rjmp	.+154    	; 0x782 <__vector_11+0x256>
				if(sendXpos==N){ // if we are DONE
 6e8:	80 91 ba 00 	lds	r24, 0x00BA	; 0x8000ba <sendXpos>
 6ec:	89 30       	cpi	r24, 0x09	; 9
 6ee:	51 f4       	brne	.+20     	; 0x704 <__vector_11+0x1d8>
					putC('D');				  // send letter D
 6f0:	84 e4       	ldi	r24, 0x44	; 68
 6f2:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <putC>
					putC(0x0D);               // send letter CR
 6f6:	8d e0       	ldi	r24, 0x0D	; 13
 6f8:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <putC>
					putC(0x0A);               // send letter LF
 6fc:	8a e0       	ldi	r24, 0x0A	; 10
 6fe:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <putC>
 702:	87 c0       	rjmp	.+270    	; 0x812 <__vector_11+0x2e6>
				}
				else{
					putC('N');				  // send letter N
 704:	8e e4       	ldi	r24, 0x4E	; 78
 706:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <putC>
					putC(sendXpos+48+1);		  // send position X=0
 70a:	80 91 ba 00 	lds	r24, 0x00BA	; 0x8000ba <sendXpos>
 70e:	8f 5c       	subi	r24, 0xCF	; 207
 710:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <putC>
					putC(sendYpos+48+1);		  // send position Y=0
 714:	80 91 bd 00 	lds	r24, 0x00BD	; 0x8000bd <sendYpos>
 718:	8f 5c       	subi	r24, 0xCF	; 207
 71a:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <putC>
					putC(grid[sendXpos][sendYpos]+48);  // send first number of grid
 71e:	80 91 ba 00 	lds	r24, 0x00BA	; 0x8000ba <sendXpos>
 722:	28 2f       	mov	r18, r24
 724:	30 e0       	ldi	r19, 0x00	; 0
 726:	80 91 bd 00 	lds	r24, 0x00BD	; 0x8000bd <sendYpos>
 72a:	48 2f       	mov	r20, r24
 72c:	50 e0       	ldi	r21, 0x00	; 0
 72e:	c9 01       	movw	r24, r18
 730:	88 0f       	add	r24, r24
 732:	99 1f       	adc	r25, r25
 734:	88 0f       	add	r24, r24
 736:	99 1f       	adc	r25, r25
 738:	88 0f       	add	r24, r24
 73a:	99 1f       	adc	r25, r25
 73c:	82 0f       	add	r24, r18
 73e:	93 1f       	adc	r25, r19
 740:	84 0f       	add	r24, r20
 742:	95 1f       	adc	r25, r21
 744:	80 5a       	subi	r24, 0xA0	; 160
 746:	9f 4f       	sbci	r25, 0xFF	; 255
 748:	fc 01       	movw	r30, r24
 74a:	80 81       	ld	r24, Z
 74c:	80 5d       	subi	r24, 0xD0	; 208
 74e:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <putC>
					putC(0x0D);               // send letter CR
 752:	8d e0       	ldi	r24, 0x0D	; 13
 754:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <putC>
					putC(0x0A);               // send letter LF
 758:	8a e0       	ldi	r24, 0x0A	; 10
 75a:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <putC>
					sendYpos=sendYpos+1;
 75e:	80 91 bd 00 	lds	r24, 0x00BD	; 0x8000bd <sendYpos>
 762:	8f 5f       	subi	r24, 0xFF	; 255
 764:	80 93 bd 00 	sts	0x00BD, r24	; 0x8000bd <sendYpos>
					if(sendYpos==N){sendYpos=0;sendXpos=sendXpos+1;}//if we sent all row send next row
 768:	80 91 bd 00 	lds	r24, 0x00BD	; 0x8000bd <sendYpos>
 76c:	89 30       	cpi	r24, 0x09	; 9
 76e:	09 f0       	breq	.+2      	; 0x772 <__vector_11+0x246>
 770:	50 c0       	rjmp	.+160    	; 0x812 <__vector_11+0x2e6>
 772:	10 92 bd 00 	sts	0x00BD, r1	; 0x8000bd <sendYpos>
 776:	80 91 ba 00 	lds	r24, 0x00BA	; 0x8000ba <sendXpos>
 77a:	8f 5f       	subi	r24, 0xFF	; 255
 77c:	80 93 ba 00 	sts	0x00BA, r24	; 0x8000ba <sendXpos>
 780:	48 c0       	rjmp	.+144    	; 0x812 <__vector_11+0x2e6>
												
				}
			}
			else if(readWord[0]=='B'){  
 782:	80 91 b1 00 	lds	r24, 0x00B1	; 0x8000b1 <readWord>
 786:	82 34       	cpi	r24, 0x42	; 66
 788:	79 f4       	brne	.+30     	; 0x7a8 <__vector_11+0x27c>
				play =0;     // it will force sudoku to stop (finish)
 78a:	10 92 bb 00 	sts	0x00BB, r1	; 0x8000bb <play>
				putC('O');        // send letter O
 78e:	8f e4       	ldi	r24, 0x4F	; 79
 790:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <putC>
				putC('K');        // send letter K
 794:	8b e4       	ldi	r24, 0x4B	; 75
 796:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <putC>
				putC(0x0D);               // send letter CR
 79a:	8d e0       	ldi	r24, 0x0D	; 13
 79c:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <putC>
				putC(0x0A);               // send letter LF
 7a0:	8a e0       	ldi	r24, 0x0A	; 10
 7a2:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <putC>
 7a6:	35 c0       	rjmp	.+106    	; 0x812 <__vector_11+0x2e6>
			}
			else if(readWord[0]=='D'){  
 7a8:	80 91 b1 00 	lds	r24, 0x00B1	; 0x8000b1 <readWord>
 7ac:	84 34       	cpi	r24, 0x44	; 68
 7ae:	89 f5       	brne	.+98     	; 0x812 <__vector_11+0x2e6>
				putC('N');				  // send letter N
 7b0:	8e e4       	ldi	r24, 0x4E	; 78
 7b2:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <putC>
				putC(readWord[1]);				  // send position X=0
 7b6:	80 91 b2 00 	lds	r24, 0x00B2	; 0x8000b2 <readWord+0x1>
 7ba:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <putC>
				putC(readWord[2]);				  // send position Y=0
 7be:	80 91 b3 00 	lds	r24, 0x00B3	; 0x8000b3 <readWord+0x2>
 7c2:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <putC>
				putC(grid[readWord[1]-48-1][readWord[2]-48-1]+48);  // send asked number (-48 and +48 to convert int to ascii)
 7c6:	80 91 b2 00 	lds	r24, 0x00B2	; 0x8000b2 <readWord+0x1>
 7ca:	88 2f       	mov	r24, r24
 7cc:	90 e0       	ldi	r25, 0x00	; 0
 7ce:	9c 01       	movw	r18, r24
 7d0:	21 53       	subi	r18, 0x31	; 49
 7d2:	31 09       	sbc	r19, r1
 7d4:	80 91 b3 00 	lds	r24, 0x00B3	; 0x8000b3 <readWord+0x2>
 7d8:	88 2f       	mov	r24, r24
 7da:	90 e0       	ldi	r25, 0x00	; 0
 7dc:	ac 01       	movw	r20, r24
 7de:	41 53       	subi	r20, 0x31	; 49
 7e0:	51 09       	sbc	r21, r1
 7e2:	c9 01       	movw	r24, r18
 7e4:	88 0f       	add	r24, r24
 7e6:	99 1f       	adc	r25, r25
 7e8:	88 0f       	add	r24, r24
 7ea:	99 1f       	adc	r25, r25
 7ec:	88 0f       	add	r24, r24
 7ee:	99 1f       	adc	r25, r25
 7f0:	82 0f       	add	r24, r18
 7f2:	93 1f       	adc	r25, r19
 7f4:	84 0f       	add	r24, r20
 7f6:	95 1f       	adc	r25, r21
 7f8:	80 5a       	subi	r24, 0xA0	; 160
 7fa:	9f 4f       	sbci	r25, 0xFF	; 255
 7fc:	fc 01       	movw	r30, r24
 7fe:	80 81       	ld	r24, Z
 800:	80 5d       	subi	r24, 0xD0	; 208
 802:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <putC>
				putC(0x0D);               // send letter CR
 806:	8d e0       	ldi	r24, 0x0D	; 13
 808:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <putC>
				putC(0x0A);               // send letter LF
 80c:	8a e0       	ldi	r24, 0x0A	; 10
 80e:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <putC>
			}
			letter=0;
 812:	10 92 b9 00 	sts	0x00B9, r1	; 0x8000b9 <letter>
			uint8_t i=0; 
 816:	10 e0       	ldi	r17, 0x00	; 0
			
			while(i<SizeOfReadWord){   //set readWord=0
 818:	09 c0       	rjmp	.+18     	; 0x82c <__vector_11+0x300>
				readWord[i]=0;
 81a:	81 2f       	mov	r24, r17
 81c:	90 e0       	ldi	r25, 0x00	; 0
 81e:	8f 54       	subi	r24, 0x4F	; 79
 820:	9f 4f       	sbci	r25, 0xFF	; 255
 822:	fc 01       	movw	r30, r24
 824:	10 82       	st	Z, r1
				i++;
 826:	81 2f       	mov	r24, r17
 828:	11 e0       	ldi	r17, 0x01	; 1
 82a:	18 0f       	add	r17, r24
				putC(0x0A);               // send letter LF
			}
			letter=0;
			uint8_t i=0; 
			
			while(i<SizeOfReadWord){   //set readWord=0
 82c:	18 30       	cpi	r17, 0x08	; 8
 82e:	a8 f3       	brcs	.-22     	; 0x81a <__vector_11+0x2ee>
				readWord[i]=0;
				i++;
			}	
		}
			asm(" pop r31\n\t\
 830:	ff 91       	pop	r31
 832:	ef 91       	pop	r30
 834:	df 91       	pop	r29
 836:	cf 91       	pop	r28
 838:	bf 91       	pop	r27
 83a:	af 91       	pop	r26
 83c:	9f 91       	pop	r25
 83e:	8f 91       	pop	r24
 840:	7f 91       	pop	r23
 842:	6f 91       	pop	r22
 844:	5f 91       	pop	r21
 846:	4f 91       	pop	r20
 848:	3f 91       	pop	r19
 84a:	2f 91       	pop	r18
 84c:	1f 91       	pop	r17
 84e:	0f 91       	pop	r16
 850:	0f 90       	pop	r0
 852:	0f be       	out	0x3f, r0	; 63
 854:	00 24       	eor	r0, r0
				pop r17 \n\t\
				pop r16 \n\t\
				pop r0	 \n\t\
				out __SREG__,r0 \n\t\
				clr r0");
	reti();
 856:	18 95       	reti
	...

0000085a <initUART>:
}


//initialize USART
void initUART(){
 85a:	cf 93       	push	r28
 85c:	df 93       	push	r29
 85e:	cd b7       	in	r28, 0x3d	; 61
 860:	de b7       	in	r29, 0x3e	; 62
	UCSRB=(1<<RXEN) | (1<<TXEN) | (1<<RXCIE);  // ; enable RXCIE=Interrupt enable ,RXEN=Receiver Enable, TXEN=Transmitter Enable
 862:	8a e2       	ldi	r24, 0x2A	; 42
 864:	90 e0       	ldi	r25, 0x00	; 0
 866:	28 e9       	ldi	r18, 0x98	; 152
 868:	fc 01       	movw	r30, r24
 86a:	20 83       	st	Z, r18
	UBRRL=(10000000/16/9600)-1;								  //; set baud rate 9600 with the formula (F_CPU/16/baud) - 1
 86c:	89 e2       	ldi	r24, 0x29	; 41
 86e:	90 e0       	ldi	r25, 0x00	; 0
 870:	20 e4       	ldi	r18, 0x40	; 64
 872:	fc 01       	movw	r30, r24
 874:	20 83       	st	Z, r18
	UCSRC=(1<<URSEL)|(0<<USBS)|(3<<UCSZ0);
 876:	80 e4       	ldi	r24, 0x40	; 64
 878:	90 e0       	ldi	r25, 0x00	; 0
 87a:	26 e8       	ldi	r18, 0x86	; 134
 87c:	fc 01       	movw	r30, r24
 87e:	20 83       	st	Z, r18
	return;
 880:	00 00       	nop
}
 882:	df 91       	pop	r29
 884:	cf 91       	pop	r28
 886:	08 95       	ret

00000888 <main>:

// initializations and infinite loop
int main(void)
{
 888:	cf 93       	push	r28
 88a:	df 93       	push	r29
 88c:	00 d0       	rcall	.+0      	; 0x88e <main+0x6>
 88e:	cd b7       	in	r28, 0x3d	; 61
 890:	de b7       	in	r29, 0x3e	; 62
		
	progress=0; // number of solved cells
 892:	10 92 bc 00 	sts	0x00BC, r1	; 0x8000bc <progress>
	uint8_t i=0;
 896:	19 82       	std	Y+1, r1	; 0x01
	while(i<SizeOfReadWord){
 898:	0a c0       	rjmp	.+20     	; 0x8ae <main+0x26>
		readWord[i]=0;
 89a:	89 81       	ldd	r24, Y+1	; 0x01
 89c:	88 2f       	mov	r24, r24
 89e:	90 e0       	ldi	r25, 0x00	; 0
 8a0:	8f 54       	subi	r24, 0x4F	; 79
 8a2:	9f 4f       	sbci	r25, 0xFF	; 255
 8a4:	fc 01       	movw	r30, r24
 8a6:	10 82       	st	Z, r1
		i++;
 8a8:	89 81       	ldd	r24, Y+1	; 0x01
 8aa:	8f 5f       	subi	r24, 0xFF	; 255
 8ac:	89 83       	std	Y+1, r24	; 0x01
int main(void)
{
		
	progress=0; // number of solved cells
	uint8_t i=0;
	while(i<SizeOfReadWord){
 8ae:	89 81       	ldd	r24, Y+1	; 0x01
 8b0:	88 30       	cpi	r24, 0x08	; 8
 8b2:	98 f3       	brcs	.-26     	; 0x89a <main+0x12>
		readWord[i]=0;
		i++;
	}
	letter=0; // next letter of readWord we can write
 8b4:	10 92 b9 00 	sts	0x00B9, r1	; 0x8000b9 <letter>
	play=0; // flag that starts ving
 8b8:	10 92 bb 00 	sts	0x00BB, r1	; 0x8000bb <play>
	sendXpos=0; // position x of next number we wanna send
 8bc:	10 92 ba 00 	sts	0x00BA, r1	; 0x8000ba <sendXpos>
	sendYpos=0; // position y of next number we wanna send*/
 8c0:	10 92 bd 00 	sts	0x00BD, r1	; 0x8000bd <sendYpos>
	
	i=0;
 8c4:	19 82       	std	Y+1, r1	; 0x01
	while(i<N){     // set grid array to 0
 8c6:	20 c0       	rjmp	.+64     	; 0x908 <main+0x80>
		uint8_t  j=0;
 8c8:	1a 82       	std	Y+2, r1	; 0x02
		while(j<N){
 8ca:	18 c0       	rjmp	.+48     	; 0x8fc <main+0x74>
			grid[i][j]=0;
 8cc:	89 81       	ldd	r24, Y+1	; 0x01
 8ce:	28 2f       	mov	r18, r24
 8d0:	30 e0       	ldi	r19, 0x00	; 0
 8d2:	8a 81       	ldd	r24, Y+2	; 0x02
 8d4:	48 2f       	mov	r20, r24
 8d6:	50 e0       	ldi	r21, 0x00	; 0
 8d8:	c9 01       	movw	r24, r18
 8da:	88 0f       	add	r24, r24
 8dc:	99 1f       	adc	r25, r25
 8de:	88 0f       	add	r24, r24
 8e0:	99 1f       	adc	r25, r25
 8e2:	88 0f       	add	r24, r24
 8e4:	99 1f       	adc	r25, r25
 8e6:	82 0f       	add	r24, r18
 8e8:	93 1f       	adc	r25, r19
 8ea:	84 0f       	add	r24, r20
 8ec:	95 1f       	adc	r25, r21
 8ee:	80 5a       	subi	r24, 0xA0	; 160
 8f0:	9f 4f       	sbci	r25, 0xFF	; 255
 8f2:	fc 01       	movw	r30, r24
 8f4:	10 82       	st	Z, r1
			j++;
 8f6:	8a 81       	ldd	r24, Y+2	; 0x02
 8f8:	8f 5f       	subi	r24, 0xFF	; 255
 8fa:	8a 83       	std	Y+2, r24	; 0x02
	sendYpos=0; // position y of next number we wanna send*/
	
	i=0;
	while(i<N){     // set grid array to 0
		uint8_t  j=0;
		while(j<N){
 8fc:	8a 81       	ldd	r24, Y+2	; 0x02
 8fe:	89 30       	cpi	r24, 0x09	; 9
 900:	28 f3       	brcs	.-54     	; 0x8cc <main+0x44>
			grid[i][j]=0;
			j++;
		}
		i++;
 902:	89 81       	ldd	r24, Y+1	; 0x01
 904:	8f 5f       	subi	r24, 0xFF	; 255
 906:	89 83       	std	Y+1, r24	; 0x01
	play=0; // flag that starts ving
	sendXpos=0; // position x of next number we wanna send
	sendYpos=0; // position y of next number we wanna send*/
	
	i=0;
	while(i<N){     // set grid array to 0
 908:	89 81       	ldd	r24, Y+1	; 0x01
 90a:	89 30       	cpi	r24, 0x09	; 9
 90c:	e8 f2       	brcs	.-70     	; 0x8c8 <main+0x40>
		i++;
	}//*/
	
	//SPL=0x5D;
	//SPH=0x04;// DEFAULT
	DDRB=0xff;  //; set portb as output
 90e:	87 e3       	ldi	r24, 0x37	; 55
 910:	90 e0       	ldi	r25, 0x00	; 0
 912:	2f ef       	ldi	r18, 0xFF	; 255
 914:	fc 01       	movw	r30, r24
 916:	20 83       	st	Z, r18
	PORTB=0;
 918:	88 e3       	ldi	r24, 0x38	; 56
 91a:	90 e0       	ldi	r25, 0x00	; 0
 91c:	fc 01       	movw	r30, r24
 91e:	10 82       	st	Z, r1
	OCR1A=1536;				//; if the same value with counter then interrupt
 920:	8a e4       	ldi	r24, 0x4A	; 74
 922:	90 e0       	ldi	r25, 0x00	; 0
 924:	20 e0       	ldi	r18, 0x00	; 0
 926:	36 e0       	ldi	r19, 0x06	; 6
 928:	fc 01       	movw	r30, r24
 92a:	31 83       	std	Z+1, r19	; 0x01
 92c:	20 83       	st	Z, r18
	TIMSK=(1<<OCIE1A);      //;enable compare interrupt for timer1
 92e:	89 e5       	ldi	r24, 0x59	; 89
 930:	90 e0       	ldi	r25, 0x00	; 0
 932:	20 e1       	ldi	r18, 0x10	; 16
 934:	fc 01       	movw	r30, r24
 936:	20 83       	st	Z, r18
	sei();				    // enable global interrupt
 938:	78 94       	sei
	TCCR1B=(1<<CS02);		//; starts the tcnt1l (counter 1B) with prescaler clk/256
 93a:	8e e4       	ldi	r24, 0x4E	; 78
 93c:	90 e0       	ldi	r25, 0x00	; 0
 93e:	24 e0       	ldi	r18, 0x04	; 4
 940:	fc 01       	movw	r30, r24
 942:	20 83       	st	Z, r18
	initUART();
 944:	0e 94 2d 04 	call	0x85a	; 0x85a <initUART>
	while(1){
		while (play==0){ //;infinite loop
 948:	05 c0       	rjmp	.+10     	; 0x954 <main+0xcc>
			DDRB=0xff;
 94a:	87 e3       	ldi	r24, 0x37	; 55
 94c:	90 e0       	ldi	r25, 0x00	; 0
 94e:	2f ef       	ldi	r18, 0xFF	; 255
 950:	fc 01       	movw	r30, r24
 952:	20 83       	st	Z, r18
	TIMSK=(1<<OCIE1A);      //;enable compare interrupt for timer1
	sei();				    // enable global interrupt
	TCCR1B=(1<<CS02);		//; starts the tcnt1l (counter 1B) with prescaler clk/256
	initUART();
	while(1){
		while (play==0){ //;infinite loop
 954:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <play>
 958:	88 23       	and	r24, r24
 95a:	b9 f3       	breq	.-18     	; 0x94a <main+0xc2>
			DDRB=0xff;
		}
			if (SolveSudoku() == 1){
 95c:	0e 94 73 01 	call	0x2e6	; 0x2e6 <SolveSudoku>
 960:	81 30       	cpi	r24, 0x01	; 1
 962:	b9 f4       	brne	.+46     	; 0x992 <main+0x10a>
				if(play==1){// if success (user didnt send break from usart)
 964:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <play>
 968:	81 30       	cpi	r24, 0x01	; 1
 96a:	51 f4       	brne	.+20     	; 0x980 <main+0xf8>
					putC('D');        // send letter K
 96c:	84 e4       	ldi	r24, 0x44	; 68
 96e:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <putC>
					putC(0x0D);       // send letter CR
 972:	8d e0       	ldi	r24, 0x0D	; 13
 974:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <putC>
					putC(0x0A);       // send letter LF
 978:	8a e0       	ldi	r24, 0x0A	; 10
 97a:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <putC>
 97e:	09 c0       	rjmp	.+18     	; 0x992 <main+0x10a>
				}
				else{
					putC('E');        // send letter E for ERROR
 980:	85 e4       	ldi	r24, 0x45	; 69
 982:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <putC>
					putC(0x0D);       // send letter CR
 986:	8d e0       	ldi	r24, 0x0D	; 13
 988:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <putC>
					putC(0x0A);       // send letter LF
 98c:	8a e0       	ldi	r24, 0x0A	; 10
 98e:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <putC>
				}
		}
		play=0;   // flag for infinite loop
 992:	10 92 bb 00 	sts	0x00BB, r1	; 0x8000bb <play>
	}
 996:	d8 cf       	rjmp	.-80     	; 0x948 <main+0xc0>

00000998 <_exit>:
 998:	f8 94       	cli

0000099a <__stop_program>:
 99a:	ff cf       	rjmp	.-2      	; 0x99a <__stop_program>
